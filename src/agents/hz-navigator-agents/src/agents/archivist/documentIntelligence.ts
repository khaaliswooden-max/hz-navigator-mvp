/**
 * ARCHIVIST - Document Intelligence Agent
 * 
 * Document parsing, evidence extraction, compliance document generation,
 * and intelligent filing for HUBZone certification records.
 */

import { PrismaClient, Prisma } from '@prisma/client';

/**
 * ARCHIVIST Agent - Document intelligence and records management
 */
export class ArchivistAgent {
  private prisma: PrismaClient;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  async execute(
    taskType: string,
    input: Record<string, unknown>,
    organizationId: string
  ): Promise<Record<string, unknown>> {
    console.log(`[ARCHIVIST] Executing: ${taskType}`);

    switch (taskType) {
      case 'generate_compliance_report':
        return await this.generateComplianceReport(organizationId, input);

      case 'generate_employee_roster':
        return await this.generateEmployeeRoster(organizationId);

      case 'generate_certification_package':
        return await this.generateCertificationPackage(organizationId);

      case 'parse_document':
        return await this.parseDocument(input.content as string, input.type as string);

      case 'extract_addresses':
        return await this.extractAddresses(input.content as string);

      case 'index_document':
        return await this.indexDocument(organizationId, input);

      case 'search_documents':
        return await this.searchDocuments(organizationId, input.query as string);

      case 'generate_audit_package':
        return await this.generateAuditPackage(organizationId, input);

      default:
        throw new Error(`[ARCHIVIST] Unknown task type: ${taskType}`);
    }
  }

  async generateComplianceReport(
    organizationId: string,
    options: Record<string, unknown>
  ): Promise<Record<string, unknown>> {
    const [org, snapshot, employees] = await Promise.all([
      this.prisma.organization.findUnique({ where: { id: organizationId } }),
      this.prisma.complianceSnapshot.findFirst({
        where: { organizationId },
        orderBy: { snapshotDate: 'desc' },
      }),
      this.prisma.employee.findMany({
        where: { organizationId, isActive: true },
        orderBy: { lastName: 'asc' },
      }),
    ]);

    const hubzoneEmployees = employees.filter(e => e.isHubzoneResident);
    const legacyEmployees = employees.filter(e => e.isLegacyEmployee);

    const report = {
      title: 'HUBZone Compliance Report',
      generatedAt: new Date().toISOString(),
      organization: {
        name: org?.name || 'Unknown',
        id: organizationId,
      },
      executiveSummary: {
        complianceStatus: (snapshot?.compliancePercentage || 0) >= 35 ? 'COMPLIANT' : 'NON-COMPLIANT',
        currentPercentage: snapshot?.compliancePercentage?.toFixed(1) || '0.0',
        requiredPercentage: '35.0',
        riskLevel: snapshot?.riskScore && snapshot.riskScore > 50 ? 'HIGH' : 'NORMAL',
      },
      workforceBreakdown: {
        totalEmployees: employees.length,
        hubzoneResidents: hubzoneEmployees.length,
        nonHubzoneResidents: employees.length - hubzoneEmployees.length,
        legacyEmployees: legacyEmployees.length,
      },
      hubzoneTypeDistribution: this.getHubzoneTypeDistribution(hubzoneEmployees),
      complianceCalculation: {
        formula: '(HUBZone Residents / Total Employees) × 100',
        calculation: `(${hubzoneEmployees.length} / ${employees.length}) × 100`,
        result: `${((hubzoneEmployees.length / (employees.length || 1)) * 100).toFixed(1)}%`,
      },
      recommendations: this.generateReportRecommendations(
        snapshot?.compliancePercentage || 0,
        employees.length
      ),
      certification: {
        statement: 'This report was generated by HZ Navigator ARCHIVIST Agent',
        timestamp: new Date().toISOString(),
        dataSource: 'HZ Navigator Database',
      },
    };

    // Store the generated report
    await this.storeDocument(organizationId, 'compliance_report', report);

    return report;
  }

  async generateEmployeeRoster(organizationId: string): Promise<Record<string, unknown>> {
    const employees = await this.prisma.employee.findMany({
      where: { organizationId },
      orderBy: [{ isActive: 'desc' }, { lastName: 'asc' }],
    });

    const roster = {
      title: 'Employee Roster - HUBZone Compliance',
      generatedAt: new Date().toISOString(),
      organizationId,
      summary: {
        total: employees.length,
        active: employees.filter(e => e.isActive).length,
        hubzoneResidents: employees.filter(e => e.isHubzoneResident && e.isActive).length,
        legacyEmployees: employees.filter(e => e.isLegacyEmployee && e.isActive).length,
      },
      employees: employees.map((emp, index) => ({
        lineNumber: index + 1,
        name: `${emp.lastName}, ${emp.firstName}`,
        status: emp.isActive ? 'Active' : 'Inactive',
        hireDate: emp.hireDate.toISOString().split('T')[0],
        address: {
          city: emp.city,
          state: emp.state,
          zipCode: emp.zipCode,
        },
        hubzoneStatus: {
          isResident: emp.isHubzoneResident ? 'Yes' : 'No',
          type: emp.hubzoneType || 'N/A',
          isLegacy: emp.isLegacyEmployee ? 'Yes' : 'No',
        },
        lastVerified: emp.lastVerified?.toISOString().split('T')[0] || 'Never',
      })),
      notes: [
        'This roster is current as of the generation date.',
        'Employee addresses should be verified quarterly.',
        'Legacy employees are counted toward 35% up to a maximum of 4.',
      ],
    };

    await this.storeDocument(organizationId, 'employee_roster', roster);

    return roster;
  }

  async generateCertificationPackage(organizationId: string): Promise<Record<string, unknown>> {
    const [org, snapshot, employees, attemptToMaintain] = await Promise.all([
      this.prisma.organization.findUnique({ where: { id: organizationId } }),
      this.prisma.complianceSnapshot.findFirst({
        where: { organizationId },
        orderBy: { snapshotDate: 'desc' },
      }),
      this.prisma.employee.findMany({
        where: { organizationId, isActive: true },
      }),
      this.prisma.attemptToMaintain.findMany({
        where: { organizationId },
        orderBy: { createdAt: 'desc' },
        take: 10,
      }),
    ]);

    const pkg = {
      title: 'HUBZone Certification Package',
      generatedAt: new Date().toISOString(),
      organization: {
        name: org?.name,
        uei: org?.uei,
        cageCode: org?.cageCode,
      },
      sections: {
        complianceStatus: {
          currentPercentage: snapshot?.compliancePercentage?.toFixed(1),
          status: (snapshot?.compliancePercentage || 0) >= 35 ? 'COMPLIANT' : 'NON-COMPLIANT',
          asOfDate: snapshot?.snapshotDate?.toISOString(),
        },
        employeeSummary: {
          total: employees.length,
          hubzoneResidents: employees.filter(e => e.isHubzoneResident).length,
          legacyEmployees: employees.filter(e => e.isLegacyEmployee).length,
        },
        attemptToMaintain: {
          documented: attemptToMaintain.length > 0,
          recentActions: attemptToMaintain.map(a => ({
            date: a.createdAt.toISOString().split('T')[0],
            action: a.actionType,
            description: a.description,
          })),
        },
      },
      requiredDocuments: [
        { name: 'Employee Roster', status: 'generated' },
        { name: 'Compliance Report', status: 'generated' },
        { name: 'Address Verifications', status: 'available' },
        { name: 'Principal Office Documentation', status: 'user_provided' },
        { name: 'Ownership Documentation', status: 'user_provided' },
      ],
      certification: {
        statement: 'I certify that the information provided is accurate and complete.',
        preparedBy: 'HZ Navigator ARCHIVIST Agent',
        date: new Date().toISOString(),
      },
    };

    await this.storeDocument(organizationId, 'certification_package', pkg);

    return pkg;
  }

  async parseDocument(content: string, type: string): Promise<Record<string, unknown>> {
    // Document parsing logic - would use NLP/ML in production
    const parsed = {
      type,
      parsedAt: new Date().toISOString(),
      contentLength: content.length,
      extractedData: {} as Record<string, unknown>,
    };

    switch (type) {
      case 'lease':
        parsed.extractedData = this.parseLeaseDocument(content);
        break;
      case 'utility_bill':
        parsed.extractedData = this.parseUtilityBill(content);
        break;
      case 'employee_record':
        parsed.extractedData = this.parseEmployeeRecord(content);
        break;
      default:
        parsed.extractedData = { rawContent: content.substring(0, 500) };
    }

    return parsed;
  }

  async extractAddresses(content: string): Promise<Record<string, unknown>> {
    // Simple address extraction - would use ML/NLP in production
    const addressPattern = /\d+\s+[\w\s]+,\s*[\w\s]+,\s*[A-Z]{2}\s*\d{5}/gi;
    const matches = content.match(addressPattern) || [];

    return {
      extractedAt: new Date().toISOString(),
      addressesFound: matches.length,
      addresses: matches.map((addr, i) => ({
        index: i + 1,
        raw: addr,
        confidence: 0.85,
      })),
      note: 'Addresses should be verified through CARTOGRAPH agent',
    };
  }

  async indexDocument(
    organizationId: string,
    input: Record<string, unknown>
  ): Promise<Record<string, unknown>> {
    const document = await this.prisma.document.create({
      data: {
        organizationId,
        title: input.title as string,
        type: input.type as string,
        content: input.content as string | undefined,
        metadata: input.metadata as Prisma.InputJsonValue || {},
        tags: input.tags as string[] || [],
      },
    });

    return {
      success: true,
      documentId: document.id,
      indexed: {
        title: document.title,
        type: document.type,
        tags: document.tags,
      },
    };
  }

  async searchDocuments(
    organizationId: string,
    query: string
  ): Promise<Record<string, unknown>> {
    // Simple search - would use full-text search in production
    const documents = await this.prisma.document.findMany({
      where: {
        organizationId,
        OR: [
          { title: { contains: query, mode: 'insensitive' } },
          { type: { contains: query, mode: 'insensitive' } },
          { tags: { hasSome: [query] } },
        ],
      },
      orderBy: { createdAt: 'desc' },
      take: 20,
    });

    return {
      query,
      resultsCount: documents.length,
      results: documents.map(d => ({
        id: d.id,
        title: d.title,
        type: d.type,
        tags: d.tags,
        createdAt: d.createdAt,
      })),
    };
  }

  async generateAuditPackage(
    organizationId: string,
    options: Record<string, unknown>
  ): Promise<Record<string, unknown>> {
    const startDate = options.startDate
      ? new Date(options.startDate as string)
      : new Date(Date.now() - 365 * 24 * 60 * 60 * 1000);
    const endDate = options.endDate
      ? new Date(options.endDate as string)
      : new Date();

    const [snapshots, employees, verifications, atmRecords] = await Promise.all([
      this.prisma.complianceSnapshot.findMany({
        where: { organizationId, snapshotDate: { gte: startDate, lte: endDate } },
        orderBy: { snapshotDate: 'asc' },
      }),
      this.prisma.employee.findMany({
        where: { organizationId },
      }),
      this.prisma.addressVerification.findMany({
        where: { employee: { organizationId }, verifiedAt: { gte: startDate, lte: endDate } },
      }),
      this.prisma.attemptToMaintain.findMany({
        where: { organizationId, createdAt: { gte: startDate, lte: endDate } },
      }),
    ]);

    const pkg = {
      title: 'HUBZone Audit Documentation Package',
      generatedAt: new Date().toISOString(),
      period: {
        start: startDate.toISOString(),
        end: endDate.toISOString(),
      },
      organizationId,
      sections: {
        complianceHistory: {
          snapshotCount: snapshots.length,
          averageCompliance: snapshots.length > 0
            ? (snapshots.reduce((sum, s) => sum + s.compliancePercentage, 0) / snapshots.length).toFixed(1)
            : 'N/A',
          belowThresholdCount: snapshots.filter(s => s.compliancePercentage < 35).length,
          snapshots: snapshots.map(s => ({
            date: s.snapshotDate.toISOString().split('T')[0],
            percentage: s.compliancePercentage.toFixed(1),
            total: s.totalEmployees,
            hubzone: s.hubzoneEmployees,
          })),
        },
        employeeRecords: {
          total: employees.length,
          active: employees.filter(e => e.isActive).length,
          roster: employees.map(e => ({
            name: `${e.lastName}, ${e.firstName}`,
            hireDate: e.hireDate.toISOString().split('T')[0],
            status: e.isActive ? 'Active' : 'Inactive',
            hubzone: e.isHubzoneResident ? 'Yes' : 'No',
            legacy: e.isLegacyEmployee ? 'Yes' : 'No',
          })),
        },
        addressVerifications: {
          count: verifications.length,
          records: verifications.slice(0, 50).map(v => ({
            date: v.verifiedAt.toISOString().split('T')[0],
            result: v.isHubzone ? 'HUBZone' : 'Non-HUBZone',
          })),
        },
        attemptToMaintain: {
          documentedActions: atmRecords.length,
          records: atmRecords.map(a => ({
            date: a.createdAt.toISOString().split('T')[0],
            action: a.actionType,
            description: a.description,
          })),
        },
      },
      completeness: {
        complianceHistory: snapshots.length >= 12 ? 'Complete' : 'Partial',
        employeeRecords: 'Complete',
        verifications: verifications.length > 0 ? 'Available' : 'Missing',
        attemptToMaintain: atmRecords.length > 0 ? 'Documented' : 'Not Required / Missing',
      },
    };

    await this.storeDocument(organizationId, 'audit_package', pkg);

    return pkg;
  }

  // ============ PRIVATE HELPER METHODS ============

  private async storeDocument(
    organizationId: string,
    type: string,
    content: Record<string, unknown>
  ): Promise<void> {
    try {
      await this.prisma.document.create({
        data: {
          organizationId,
          title: `${type}_${new Date().toISOString().split('T')[0]}`,
          type,
          content: JSON.stringify(content),
          metadata: { generatedBy: 'ARCHIVIST', version: '1.0' },
        },
      });
    } catch (error) {
      console.error('[ARCHIVIST] Failed to store document:', error);
    }
  }

  private getHubzoneTypeDistribution(
    employees: Array<{ hubzoneType: string | null }>
  ): Record<string, number> {
    const distribution: Record<string, number> = {};
    for (const emp of employees) {
      const type = emp.hubzoneType || 'Unspecified';
      distribution[type] = (distribution[type] || 0) + 1;
    }
    return distribution;
  }

  private generateReportRecommendations(percentage: number, total: number): string[] {
    const recommendations: string[] = [];

    if (percentage < 35) {
      const needed = Math.ceil(0.35 * total) - Math.floor(percentage * total / 100);
      recommendations.push(`Hire ${needed}+ HUBZone resident(s) to reach compliance`);
      recommendations.push('Review grace period eligibility');
    } else if (percentage < 40) {
      recommendations.push('Build compliance buffer through targeted hiring');
    }

    recommendations.push('Verify employee addresses quarterly');
    recommendations.push('Monitor HUBZone map changes');

    return recommendations;
  }

  private parseLeaseDocument(content: string): Record<string, unknown> {
    return {
      documentType: 'lease',
      parsed: true,
      note: 'Full parsing requires ML integration',
    };
  }

  private parseUtilityBill(content: string): Record<string, unknown> {
    return {
      documentType: 'utility_bill',
      parsed: true,
      note: 'Full parsing requires ML integration',
    };
  }

  private parseEmployeeRecord(content: string): Record<string, unknown> {
    return {
      documentType: 'employee_record',
      parsed: true,
      note: 'Full parsing requires ML integration',
    };
  }
}
